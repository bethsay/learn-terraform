Terraform allows us to create cloud-agnostic IaC.
All terraform files that we create should have the extention ".tf"
Once Iac is prepared, we get terraform to process all of it with the below command.
    #terraform plan
Once its processed and the output looks good to us, we can use terraform to create that infrastucture with the below command.
    #terraform apply
If you want to delete all the cloud resources created by terraform, then use
    #terraform destroy
Write .tf files -> terraform plan -> terraform apply
terraform Plan will read files and tell us what changes will happen. Once we approve, we should run terraform apply

Lets start with installing terraform on ubuntu
    #wget -O - https://apt.releases.hashicorp.com/gpg | gpg --dearmor -o /etc/apt/keyrings/hashicorp-archive-keyring.gpg
    #echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(grep -oP '(?<=UBUNTU_CODENAME=).*' /etc/os-release || lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
    #sudo apt update && sudo apt install terraform
    #terraform -help
To enable autocompletion for terraform commands. This will append a line to ~/.bashrc
    #terraform -install-autocomplete
For other systems, check https://developer.hashicorp.com/terraform/install

Lets understand the major/basic components of a terraform project.
    #mkdir basics && cd basics
After we create our Iac, Terraform needs to convert it to the actual apis of that specific cloud vendor. This is done by terraform providers.
Hashicorp and its partners have published these "providers" package at https://registry.terraform.io/browse/providers
Lets start off with using the local provider which has the simple capability of creating files in the local systems.
    #vim providers.tf
Lets paste the code we get when clicking on "Use Provider" at https://registry.terraform.io/providers/hashicorp/local/latest into providers.tf
Now, we need to install this provider package.
    #terraform init
This creates a .terraform folder tree to download the binaries/packages of the required_providers and a .terraform.lock.hcl
If any modification is made to required_providers block, we must re-run terraform init
At the terrform registry page, the Documentation of every provider, will list and describe all the resources that can be managed by the provider.
For local provider, we can create local_file and local_sensitive_file resources. https://registry.terraform.io/providers/hashicorp/local/latest/docs/resources/file
    #vim resources.tf
Lets paste the code of the local_file resource.
Lets process our Iac with
    #terraform plan
This command will describe to us all the creations and deletions terraform intends to perform.
If the plan looks good lets implement it with
    #terraform apply
Terraform apply command includes the terraform plan command. Its okay to skip it.
After the first run of terraform apply, it creates a terraform.tfstate file. tfstate file holds the detailed report of resources created by terraform.
Lets make modifications to resource file and see how terraform responds
Keep in mind, the combination or resource_name + resource_type must be unique within a terraform project
    #vim main.tf
        ->Duplicate the local_file block.
    #terraform apply
        ->Error: Duplicate resource
    #vim main.tf
        ->Use unique values for resource_name, content and filename.
        ->There wont be error if content and filename are not unique, but results will be problematic
    #terraform apply
From the second run of the terraform apply, terraform.tfstate is renamed to terrform.tfstate.backup and a new terraform.tfstate is created. To see if any resources were destroyed or to do a before-after comparison, this would be useful
    #sdiff -s terraform.tfstate terraform.tfstate.backup
    #vim resource.tf
        ->Add a local_sensitive_file block
    #terraform apply
You will see that the content of the sensitive_resource is masked while the plan was being processed.
This is how keys, passwords and other sensitive variables will be handled by terraform.
Have a look at the tfstate file and the sensitive_resource created by the latest apply.
    #less terraform.tfstate
    #cat training/sensitive_file_by_tf.txt
The sensitive data will be used as is within the tfstate and the resource.
To delete/destroy all resource tracked by the tfstate (not the Iac) use
    #terraform destroy

While every resource have their own unique arguments, they also support terraforms meta-arguments like count, depends_on, for_each, lifecycle. https://developer.hashicorp.com/terraform/language/meta-arguments
Lets try the count meta-argument.
    #vim main.tf
        ->Add count = 4 into latest local_file blocks
        ->Use the ${count.index} parameter into its filename as well.
    #terraform apply
    #ls -lah training/
    #less terraform.tfstate
Using the -target flag in plan, apply, or destroy command can get terraform to operate on a specific resource.
    #terraform destroy -target=local_file.another_resource[2]
    #terraform apply -target=local_file.another_resource[2]
It is not standard practice to use -target. Its best to edit/comment all the changes in main.tf.
Lets revisit this for other meta-arguments.

Terraform plan will read our .tf files, parse it with the required_providers installed during init. This can be saved as a plan file.
This is the content that is actually used by terraform. This is then again converted to an output that we can read and understand.
    #terraform plan -out ./local.tfplan
        ->You can see in stdout the actions that terraform will do if the plan is executed.
        ->This also creates a local.tfplan file. We cant read the file but it can be processed by any terraform client.
    #terraform show ./local.tfplan
        ->This allows us to read a plan before execution
Until now, when terraform apply was run, the plan was shown and we had to approve it for execution.
If we instead try to apply this local.tfplan, we will not see the plan in the stdout and terrform will not wait for an approval before executing it.
    #terraform apply local.tfplan
The plan is bound to the tfstate file during its creation. If the tfstate changes before the plan is applied, it will be considered as stale and cannot be used.
This means the same plan cannot be reused because applying it causes the state to change and the plan to become stale.
Our .tf files can be parsed by terraform plan to create a destroy plan.
    #terraform plan -destroy -out ./local.tfplan
    #terraform show ./local.tfplan
    #terraform apply local.tfplan
Cleaup the stale plan
    #rm local.tfplan
Terraform can execute an apply or destroy without asking for approval when using the flag -auto-approve
    #terraform apply -auto-approve
    #terraform apply -destroy -auto-approve
        ->Same as terraform destroy -auto-approve

Every terraform apply implements the plan and update the terraform.tfstate
    #less terraform.tfstate
Another way to read the current state is with the terraform state command
    #terraform state -h
    #terraform state list
        ->Lists all resource.identifier managed in this terraform workspace.
    #terraform state show resource_type.resource_name
        ->Check the details of any of resource.identifier mentioned in the list command.
    #terraform state show local_sensitive_file.sensitive_resource
        ->sensitive data of any resource will be masked just as it was in the stdout of plan and apply
While the state show command will mask sensitive data, it is stored as plain text in terraform.tfstate
By default, tfstate is stored locally in the workspace which is unsecure.
You can maintain tfstate at a remote secure location by defining a backend configuration. Lets try s3 as a backend.
    #vim providers.tf
        ->terraform {
        ->  required_providers {...}
        ->  backend "s3" {
        ->    bucket = "mybucket"
        ->    key    = "path/to/my/key"
        ->    region = "us-east-1"
        ->  }
        ->}
Other backends include remote(hcp or enterprise), azurerm blob, googlecs, postgres, k8secret, http, https://developer.hashicorp.com/terraform/language/backend
Lets revisit to check the subcommands of terraform state.

When plan or apply is being run, the tfstate is pulled into memory. It is compared and updated with the actual infrastucture Configuration.
State Drift is said to have occured if the actual infra is different from the tfstate. This can also be seen as modifications of the in-memory tfstate.
State Drift happens when actual infra is modified without terraform. Here actual state will be different from state file and code.tf
The plan or apply commands then parse tf files of the workspace with provider and is again compared with the in-memory tfstate and the difference is outputted to us for approval.
Lets cause State Drift in our workspace.
    #cd basics
    #echo "State Drift is happening" > ./training/file_by_tf.txt
Is this change detected by tf state?
    #less terraform.tfstate
    #terraform state show local_file.resource_name
To see the effect of state drift on tfstate
    #terraform plan -refresh-only
If state drift is unexpected, correct it by applying the IaC and overwrite actual state
    #terraform plan
    #terraform apply
If state drift is intentional and if it must not be corrected by terraform, use the refresh command to update the tfstate reflects the actual state.
    #terraform refresh
Terrform modifications is either a create or destroy. Very rarely change is considered.
So resources that have undergone state drift are often considered as destryed resources according to terraform.
Just as terrform apply includes a plan stage, terraform plan includes a refresh stage.

input, output and local are the types of variables available in terraform
mkdir terraform_vars
vim providers.tf --> skip backend block
terraform init
vim main.tf --> create 3 local_file blocks
vim variables.tf
	variable "file1" {
	  description = file1
	  default = "sample1"
	  type = string
	}
	variable "file2" {...}
	variable "file3" {...}
vim main.tf
	resource "local_file" "sample1" {
	  content  = "...This is ${var.file1}...!!"
	  filename = "${path.module}/${var.file1}.txt"
	}
	resource "local_file" "sample2" {...}
	resource "local_file" "sample3" {...}
terraform plan
vim variables.tf --> Append at the end
	variable "count" {
	  type = number
	  default = 1
	}
vim main.tf --> Update each block
	resource "local_file" "sample1" {
	  count = var.count
	}
terraform plan
terraform plan -var count=5
vim myvalues.auto.tfvars OR vim terraform.tfvars
	file1 = "server"
	file2 = "client"
	count = 2
terraform plan
vim main.tf --> Append local at the top and update path of each resource
	local {
	  local_path = "${path.module}/parent/child"
	}
	resource "local_file" "sample1" {
	  path = "${local.local_path}/${var.file1}.txt"
	}
terraform plan
vim main.tf --> Update local and resource
	local {
	  env = "dev"
	  env_caps = upper (env)
	  local_path = "${path.module}/${local.env_caps}/${local.env}"
	}
	resource "local_path" "sample1" {
	  content = "...This is ${var.file1} in the ${local.env_caps} environment...!!"
	  filename = ...
	  count = ...
	}
terraform plan
vim output.tf
	output "path" {
	  value = "All your files are created in ${local.local_path}"
	  sensitive = false
	}
terraform plan

Modules are a full working terraform folder that can be reused.
Any project of your will be the root module. This will contain multiple child and/or published modules. Let use terraform_vars as a child module
mkdir -p terraform_root_module/child_module
vim child_module/main.tf
	terraform {
	  required_providers {
	    local = {
	      source = "hashicorp/local"
	      version = "2.5.1"
	    }
	  }
	}
	resource "local_file" "file" {
	  content  = var.file_content
	  filename = "${path.module}/${var.file_name}.txt"
	}
vim child_module/variable.tf
	variable "file_name" {
	  description = "file name"
	  default = file.txt
	  type = string
	}
	variable "file_content" {
	  description = "file content"
	  default = "...This is content of ${var.file1}...!!"
	  type = string
	}
vim child_module/output.tf
	output "file_path" {
	  value = "Your file is created in ${local_file.file.filename}"
	  sensitive = false
	}
vim main.tf
	terraform {
	  required_providers {
	    local = {
	      source = "hashicorp/local"
	      version = "2.5.1"
	    }
	  }
	}
	local {
	  files {
	    Mainfile = "This is content of main file"
	    Subfile = "Other information is available here"
	module "create_file" {
	  source = "./child_module"
	  for_each = local.files

	  file_name = 
	  file_content = "I should not see default content"
	}



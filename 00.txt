Terraform allows us to create cloud-agnostic IaC.
All terraform files that we create should have the extention ".tf"
Once Iac is prepared, we get terraform to process all of it with the below command.
    #terraform plan
Once its processed and the output looks good to us, we can use terraform to create that infrastucture with the below command.
    #terraform apply
If you want to delete all the cloud resources created by terraform, then use
    #terraform destroy
Write .tf files -> terraform plan -> terraform apply
terraform Plan will read files and tell us what changes will happen. Once we approve, we should run terraform apply

Lets start with installing terraform on ubuntu
    #wget -O - https://apt.releases.hashicorp.com/gpg | gpg --dearmor -o /etc/apt/keyrings/hashicorp-archive-keyring.gpg
    #echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(grep -oP '(?<=UBUNTU_CODENAME=).*' /etc/os-release || lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
    #sudo apt update && sudo apt install terraform
    #terraform -help
To enable autocompletion for terraform commands. This will append a line to ~/.bashrc
    #terraform -install-autocomplete
For other systems, check https://developer.hashicorp.com/terraform/install

Lets understand the core/basic concepts of a terraform project.
    #mkdir basics && cd basics
After we create our Iac, Terraform needs to convert it to the actual apis of that specific cloud vendor. This is done by terraform providers.
Hashicorp and its partners have published these "providers" package at https://registry.terraform.io/browse/providers
Lets start off with using the local provider which has the simple capability of creating files in the local systems.
    #vim providers.tf
Lets paste the code we get when clicking on "Use Provider" at https://registry.terraform.io/providers/hashicorp/local/latest into providers.tf
Now, we need to install this provider package.
    #terraform init
This creates a .terraform folder tree to download the binaries/packages of the required_providers and a .terraform.lock.hcl
If any modification is made to required_providers block, we must re-run terraform init
At the terrform registry page, the Documentation of every provider, will list and describe all the resources that can be managed by the provider.
For local provider, we can create local_file and local_sensitive_file resources. https://registry.terraform.io/providers/hashicorp/local/latest/docs/resources/file
    #vim resources.tf
Lets paste the code of the local_file resource. Lets process our Iac with
    #terraform plan
This command will describe to us all the creations and deletions terraform intends to perform.
If the plan looks good lets implement it with
    #terraform apply
Terraform apply command includes the terraform plan command. Its okay to skip it.
After the first run of terraform apply, it creates a terraform.tfstate file. tfstate file holds the detailed report of resources created by terraform.
Lets make modifications to resource file and see how terraform responds
Keep in mind, the combination or resource_name + resource_type must be unique within a terraform project
    #vim resources.tf
        ->Duplicate the local_file block.
    #terraform apply
        ->Error: Duplicate resource
    #vim resources.tf
        ->Use unique values for resource_name, content and filename.
        ->There wont be error if content and filename are not unique, but results will be problematic
    #terraform apply
From the second run of the terraform apply, terraform.tfstate is renamed to terrform.tfstate.backup and a new terraform.tfstate is created. To see if any resources were destroyed or to do a before-after comparison, this would be useful
    #sdiff -s terraform.tfstate terraform.tfstate.backup
    #vim resources.tf
        ->Add a local_sensitive_file block
    #terraform apply
You will see that the content of the sensitive_resource is masked while the plan was being processed.
This is how keys, passwords and other sensitive variables will be handled by terraform.
Have a look at the tfstate file and the sensitive_resource created by the latest apply.
    #less terraform.tfstate
    #cat training/sensitive_file_by_tf.txt
The sensitive data will be used as is within the tfstate and the resource.
To delete/destroy all resource tracked by the tfstate (not the Iac) use
    #terraform destroy

Terraform plan will read our .tf files, parse it with the required_providers installed during init. This can be saved as a plan file.
This is the content that is actually used by terraform. This is then again converted to an output that we can read and understand.
    #cd basics
    #terraform plan -out ./local.tfplan
        ->You can see in stdout the actions that terraform will do if the plan is executed.
        ->This also creates a local.tfplan file. We cant read the file but it can be processed by any terraform client.
    #terraform show ./local.tfplan
        ->This allows us to read a plan before execution
Until now, when terraform apply was run, the plan was shown and we had to approve it for execution.
If we instead try to apply this local.tfplan, we will not see the plan in the stdout and terrform will not wait for an approval before executing it.
    #terraform apply local.tfplan
The plan is bound to the tfstate file during its creation. If the tfstate changes before the plan is applied, it will be considered as stale and cannot be used.
This means the same plan cannot be reused because applying it causes the state to change and the plan to become stale.
Our .tf files can be parsed by terraform plan to create a destroy plan.
    #terraform plan -destroy -out ./local.tfplan
    #terraform show ./local.tfplan
    #terraform apply local.tfplan
Cleaup the stale plan
    #rm local.tfplan
Terraform can execute an apply or destroy without asking for approval when using the flag -auto-approve
    #terraform apply -auto-approve
    #terraform apply -destroy -auto-approve
        ->Same as terraform destroy -auto-approve

Every terraform apply implements the plan and update the terraform.tfstate
    #cd basics
    #less terraform.tfstate
Another way to read the current state is with the terraform state command
    #terraform state -h
    #terraform state list
        ->Lists all resource.identifier managed in this terraform workspace.
    #terraform state show resource_type.resource_name
        ->Check the details of any of resource.identifier mentioned in the list command.
    #terraform state show local_sensitive_file.sensitive_resource
        ->sensitive data of any resource will be masked just as it was in the stdout of plan and apply
While the state show command will mask sensitive data, it is stored as plain text in terraform.tfstate
By default, tfstate is stored locally in the workspace which is unsecure.
You can maintain tfstate at a remote secure location by defining a backend configuration. Lets try s3 as a backend.
    #vim providers.tf
        ->terraform {
        ->  required_providers {...}
        ->  backend "s3" {
        ->    bucket = "mybucket"
        ->    key    = "path/to/my/key"
        ->    region = "us-east-1"
        ->  }
        ->}
Other backends include remote(hcp or enterprise), azurerm blob, googlecs, postgres, k8secret, urls. https://developer.hashicorp.com/terraform/language/backend
Lets revisit to check the subcommands of terraform state.

When plan or apply is being run, the tfstate is pulled into memory. It is compared and updated with the actual infrastucture Configuration.
State Drift is said to have occured if the actual infra is different from the tfstate. This can also be seen as modifications of the in-memory tfstate.
State Drift happens when actual infra is modified without terraform. Here actual state will be different from state file and code.tf
The plan or apply commands then parse tf files of the workspace with provider and is again compared with the in-memory tfstate and the difference is outputted to us for approval.
Lets cause State Drift in our workspace.
    #cd basics
    #echo "State Drift is happening" > ./training/file_by_tf.txt
Is this change detected by tf state?
    #less terraform.tfstate
    #terraform state show local_file.resource_name
To see the effect of state drift on tfstate
    #terraform plan -refresh-only
If state drift is unexpected, correct it by applying the IaC and overwrite actual state
    #terraform plan
    #terraform apply
If state drift is intentional and if it must not be corrected by terraform, use the refresh command to update the tfstate reflects the actual state.
    #terraform refresh
Terrform modifications is either a create or destroy. Very rarely change is considered.
So resources that have undergone state drift are often considered as destryed resources according to terraform.
Just as terrform apply includes a plan stage, terraform plan includes a refresh stage.

Every resource_type have their own unique arguments whose values allows us to codeify resource creation.
Terraform has meta-arguments (count, depends_on, for_each) to be used on any resource, and are not restricted by type. https://developer.hashicorp.com/terraform/language/meta-arguments
The count meta-argument can be used to create copies of a resource
    #cd basics
    #vim resources.tf
        ->Add count = 4 into latest local_file blocks
        ->Use the ${count.index} parameter into its filename as well.
    #terraform apply
    #ls -lah training/
    #less terraform.tfstate
Using the -target flag in plan, apply, or destroy command can get terraform to operate on a specific resource.
    #terraform destroy -target=local_file.another_resource[2]
    #terraform apply -target=local_file.another_resource[2]
It is not standard practice to use -target. Its best to edit/comment all the changes in main.tf.
Lets revisit this for other meta-arguments.

Terraform variables block allows us to reuse the code in different workspaces without needing to edit the code. https://developer.hashicorp.com/terraform/language/block/variable
Initialize a new workspace (directory or folder) with a local povider
    #mkdir terraform_vars
    #vim providers.tf
        ->Use the hashicorp/local as a required_providers.
    #terraform init
Define 2 string variables with a default values.
    #vim variables.tf
Use these variables as filename for local_file resources.
    #vim main.tf
Create the resources
    #terraform plan
    #terraform apply
Add a number variable with a default value
    #vim variables.tf
Use that number as resource multiplier using count meta-arguments in both resources.
While Terraform indexes these resource copies starting from 0 to n-1. We are allowed to use math to number it however we want.
Update filename to have a incremental parent directory of count.index+1
    #vim main.tf
Update the resources
    #terraform apply
If default value is not set for a variable, terraform will prompt the value during plan/apply.
    #variables.tf
        ->Comment out default value of replica
    #terraform apply
    #variables.tf
        ->Uncomment default value of replica
Updating the value of an input variable can by done during plan or apply using "-var"
    #terraform apply -var replica=5
But most often you would maintain all your variables in a file.
Create a file with key=value pairs. Ensure key is same as the variables used.
    #vim values.txt
Pass this file name with the -var-file flag in plan or apply command.
    #terraform plan -var-file values.txt
For the values file to be picked up by terraform without -var-file, it must be named terraform.tfvars or have the extention *.auto.tfvars
    #mv values.txt terraform.tfvars
    #terraform plan
    #mv terraform.tfvars my_values.auto.tfvars
    #terraform apply
    #mv my_values.auto.tfvars values.txt
The types of variables available are string, number, bool, list, set, map. https://developer.hashicorp.com/terraform/language/expressions/types

Terraform locals block allows for the substitution of repeating values within a workspace with a key.
locals block is also used to maintain the value of a funtion/expression in a key that can be used repeatedly.
This is better than processing the function repeatedly. https://developer.hashicorp.com/terraform/language/functions
    #cd variables
Create a local block to convert a string to uppercase and use that as the new parent directory of all local_file resources.
    #vim main.tf
    #terraform apply -var-file values.txt
Lets create new variables
    #vim output.tf
    #terraform plan

Modules are a full working terraform folder that can be reused.
Any project of your will be the root module. This will contain multiple child and/or published modules. Let use terraform_vars as a child module
mkdir -p terraform_root_module/child_module
vim child_module/main.tf
	terraform {
	  required_providers {
	    local = {
	      source = "hashicorp/local"
	      version = "2.5.1"
	    }
	  }
	}
	resource "local_file" "file" {
	  content  = var.file_content
	  filename = "${path.module}/${var.file_name}.txt"
	}
vim child_module/variable.tf
	variable "file_name" {
	  description = "file name"
	  default = file.txt
	  type = string
	}
	variable "file_content" {
	  description = "file content"
	  default = "...This is content of ${var.file1}...!!"
	  type = string
	}
vim child_module/output.tf
	output "file_path" {
	  value = "Your file is created in ${local_file.file.filename}"
	  sensitive = false
	}
vim main.tf
	terraform {
	  required_providers {
	    local = {
	      source = "hashicorp/local"
	      version = "2.5.1"
	    }
	  }
	}
	local {
	  files {
	    Mainfile = "This is content of main file"
	    Subfile = "Other information is available here"
	module "create_file" {
	  source = "./child_module"
	  for_each = local.files

	  file_name = 
	  file_content = "I should not see default content"
	}


